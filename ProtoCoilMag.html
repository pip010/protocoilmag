<!DOCTYPE html>
<html>
    <head>
	<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
		<!--
		TODO:
		[1] Free Camera
		[2]
		[3]
		-->
		<title>DeNaCoR :: ProtoMag v0.1</title>
        <script src="http://code.jquery.com/jquery-1.10.1.min.js"></script>
		<script src="http://code.jquery.com/jquery-migrate-1.2.1.min.js"></script>
		<script src="http://code.jquery.com/ui/1.10.3/jquery-ui.js"></script>
		<!--[if lt IE 9]>
			<script src="excanvas.js"></script>
		<![endif]-->
		<script src="http://rawgithub.com/mrdoob/three.js/master/build/three.min.js"></script>
		<script src="http://rawgithub.com/mrdoob/three.js/master/examples/js/controls/TrackballControls.js"></script>
		<script src="http://www.numericjs.com/lib/numeric-1.2.6.min.js"></script>

		<script type='text/javascript' src='js/dat.gui.min.js'></script>
		
		<link rel=stylesheet href="css/jquery-ui.css" />
		<style type="text/css">
			body {
				background-color: #222;
				color : white;
				table-layout:fixed
			}
			
			#progressbar_container
			{
				width: 600px;
				border: 1px solid #ddd;
				border-radius: 5px; 
				overflow: hidden;
				display:inline-block;
				margin:0px 10px 5px 5px;
				vertical-align:top;
			}
			
			#progressbar 
			{
				color: #fff;
				text-align: right;
				height: 25px;
				width: 0;
				background-color: #0ba1b5; 
				border-radius: 3px; 
			}

		  #divHelloWorld
		  {
			  display: none;
		  }

			#maintoolbar li
			{
				list-style-type: none;
				padding: 0;
				margin: 0;

			}

			/*
			.infield_v li
			{
				display: block;
				float: left;
			}
			
			.infield_h li
			{
				display: inline;
			}
			*/

			.fields
			{
				display: inline-block;
				vertical-align: top;
				background-color: rgba(255,255,255, 0.2);
				border : 1px solid #666;
				box-shadow: 1px 1px 0 #111;
			}

			.fields legend {
				text-shadow: 1px 1px 0 #111;
			}

			input[type=number] {
				width : 3em;
			}

    </style>
		<script type="text/javascript" >
		
		//holly Pi
		pi = Math.atan(1)*4;
		
		// custom global variables
		var gui, gui_zText, 
			gui_xMin, gui_xMax, gui_yMin, gui_yMax,
			gui_a, gui_b, gui_c, gui_d,
			gui_segments;
		var zFuncText = "x^2 - y^2";
		
		// parameters for the equations
		var a = 0.01, b = 0.01, c = 0.01, d = 0.01;

		var meshFunction;
		var segments = 20, 
		xMin = -10, xMax = 10, xRange = xMax - xMin,
		yMin = -10, yMax = 10, yRange = yMax - yMin,
		zMin = -10, zMax = 10, zRange = zMax - zMin;

		function setProgress(progress)
		{           
			var progressBarWidth =progress*$("#progressbar_container").width()/ 100;  
			$("#progressbar").width(progressBarWidth).html(progress + "% ");
		}
		
		$(document).ready(function(){

			console.log(' Page Loaded ');
			
			loadGUI();
			
			$('#divHelloWorld').fadeIn(2000);

			$('#camera_x').change(function (evt) {
				RunVisualization();
			});
			$('#camera_y').change(function (evt) {
				RunVisualization();
			});
			$('#camera_z').change(function (evt) {
				RunVisualization();
			});

			$('#camera_rotx').change(function (evt) {
				RunVisualization();
			});
			$('#camera_roty').change(function (evt) {
				RunVisualization();
			});
			$('#camera_rotz').change(function (evt) {
				RunVisualization();
			});

			$('#gosim').click(function(event){
				RunSimulation();
			});

			$('#govis').click(function(event){
				RunVisualization();
			});

			$('#domaindim').change(function (evt) {
				$('#sliderfieldcutter').attr('max', $(this).val());
				RunSimulation();
				RunVisualization();
			});

			$('#sliderfieldcutter').change(function (evt) {
				RunVisualization();
			});

			$('input:radio[name=cameratype]').change(function (evt) {
				RunVisualization();
			});

			$('#set_camerax').click(function (evt) {
				RunVisualization();
			});
			$('#set_cameray').click(function (evt) {
				RunVisualization();
			});
			$('#set_cameraz').click(function (evt) {
				RunVisualization();
			});
		});
		
		/*
		function RotateXXX()
		{
			var rotX = parseFloat($('#camera_rotx').get(0).value);
			var rotY = parseFloat($('#camera_roty').get(0).value);
			var rotZ = parseFloat($('#camera_rotz').get(0).value);
			
			rotX = rotX == 0 ? 0 : pi/rotX;
			rotY = rotY == 0 ? 0 : pi/rotY;
			rotZ = rotZ == 0 ? 0 : pi/rotZ;
			
			ProtoMag.root.rotation.x = rotX;
			ProtoMag.root.rotation.y = rotY;
			ProtoMag.root.rotation.z = rotZ;
		}*/

		function loadGUI()
		{
			///////////////////
			//   GUI SETUP   //	
			///////////////////

			gui = new dat.GUI();
			
			parameters = 
			{
				resetCam:  function() { resetCamera(); },	
				preset1:   function() { preset01(); },
				graphFunc: function() { createGraph(); },
				finalValue: 337
			};

			// GUI -- equation
			gui_zText = gui.add( this, 'zFuncText' ).name('z = f(x,y) = ');
			gui_xMin = gui.add( this, 'xMin' ).name('x Minimum = ');
			gui_xMax = gui.add( this, 'xMax' ).name('x Maximum = ');
			gui_yMin = gui.add( this, 'yMin' ).name('y Minimum = ');
			gui_yMax = gui.add( this, 'yMax' ).name('y Maximum = ');
			gui_segments = gui.add( this, 'segments' ).name('Subdivisions = ');

			// GUI -- parameters
			var gui_parameters = gui.addFolder('Parameters');
			a = b = c = d = 0.01;
			gui_a = gui_parameters.add( this, 'a' ).min(-5).max(5).step(0.01).name('a = ');
			//gui_a.onChange( function(value) { createGraph(); } );
			gui_b = gui_parameters.add( this, 'b' ).min(-5).max(5).step(0.01).name('b = ');
			//gui_b.onChange( function(value) { createGraph(); } );
			gui_c = gui_parameters.add( this, 'c' ).min(-5).max(5).step(0.01).name('c = ');
			//gui_c.onChange( function(value) { createGraph(); } );
			gui_d = gui_parameters.add( this, 'd' ).min(-5).max(5).step(0.01).name('d = ');
			//gui_d.onChange( function(value) { createGraph(); } );
			gui_a.setValue(1);
			gui_b.setValue(1);
			gui_c.setValue(1);
			gui_d.setValue(1);

			// GUI -- preset equations
			var gui_preset = gui.addFolder('Preset equations');
			gui_preset.add( parameters, 'preset1' ).name('Sine Circles');

			gui.add( parameters, 'resetCam' ).name("Reset Camera");
			gui.add( parameters, 'graphFunc' ).name("Graph Function");	
			
 			//function preset01()
			//{
			//	gui_zText.setValue("sin(sqrt(a*x^2  + b*y^2))");
			//	gui_xMin.setValue(-10); gui_xMax.setValue(10);
			//	gui_yMin.setValue(-10); gui_yMax.setValue(10);
			//	gui_a.setValue(1);
			//	gui_b.setValue(1);
			//	gui_segments.setValue(40);
			//	createGraph(); resetCamera();
			//}
			
			/*
			SAMPLES:
			
				/////////
	// GUI //
	/////////
	
	gui = new dat.GUI();
	parameters = 
	{ c: 1.0, p: 1.4, bs: false, fs: true, nb: false, ab: true, mv: true, color: "#ffff00" };
	
	var top = gui.addFolder('Glow Shader Attributes');
	
	var cGUI = top.add( parameters, 'c' ).min(0.0).max(1.0).step(0.01).name("c").listen();
	cGUI.onChange( function(value) { 
		moonGlow.material.uniforms[ "c" ].value = parameters.c; 
		crateGlow.material.uniforms[ "c" ].value = parameters.c; 
	});
	
	var pGUI = top.add( parameters, 'p' ).min(0.0).max(6.0).step(0.01).name("p").listen();
	pGUI.onChange( function(value) { 
		moonGlow.material.uniforms[ "p" ].value = parameters.p; 
		crateGlow.material.uniforms[ "p" ].value = parameters.p; 	
	});

	var glowColor = top.addColor( parameters, 'color' ).name('Glow Color').listen();
	glowColor.onChange( function(value) {
		moonGlow.material.uniforms.glowColor.value.setHex( value.replace("#", "0x"));   
		crateGlow.material.uniforms.glowColor.value.setHex( value.replace("#", "0x"));   
	});
	top.open();
	
	// toggle front side / back side 
	var folder1 = gui.addFolder('Render side');
	var fsGUI = folder1.add( parameters, 'fs' ).name("THREE.FrontSide").listen();
	fsGUI.onChange( function(value) { 
	    if (value) 
	    {
	        bsGUI.setValue(false);
			moonGlow.material.side = THREE.FrontSide;  
			crateGlow.material.side = THREE.FrontSide;  
	    }
	});
	var bsGUI = folder1.add( parameters, 'bs' ).name("THREE.BackSide").listen();
	bsGUI.onChange( function(value) { 
		if (value)
		{
			fsGUI.setValue(false);
			moonGlow.material.side = THREE.BackSide;  
			crateGlow.material.side = THREE.BackSide;  
		}
	});
	folder1.open();
	
	// toggle normal blending / additive blending
	var folder2 = gui.addFolder('Blending style');
	var nbGUI = folder2.add( parameters, 'nb' ).name("THREE.NormalBlending").listen();
	nbGUI.onChange( function(value) { 
	    if (value) 
	    {
	        abGUI.setValue(false);
			moonGlow.material.blending = THREE.NormalBlending;  
			crateGlow.material.blending = THREE.NormalBlending;
	    }
	});
	var abGUI = folder2.add( parameters, 'ab' ).name("THREE.AdditiveBlending").listen();
	abGUI.onChange( function(value) { 
		if (value)
		{
			nbGUI.setValue(false);
			moonGlow.material.blending = THREE.AdditiveBlending; 
			crateGlow.material.blending = THREE.AdditiveBlending;
		}
	});
	folder2.open();

    // toggle mesh visibility
	var folder3 = gui.addFolder('Miscellaneous');
	var mvGUI = folder3.add( parameters, 'mv' ).name("Meshes-Visible").listen();
	mvGUI.onChange( function(value) { 
		moon.visible = value; 
		crate.visible = value;
	});
	folder3.open();
			
			*/
		}
		function RunSimulation()
		{
			var domaindim = parseFloat($('#domaindim').val());
			var coilloops = parseFloat($('#coilloops').val());
			var coilsegments = parseFloat($('#coilsegs').val());
			var stepx = parseFloat($('#domain_step_x').val());
			var stepy = parseFloat($('#domain_step_y').val());
			var stepz = parseFloat($('#domain_step_z').val());
			
			ProtoMag.Sim({
				dim : domaindim, 
				loops : coilloops,
				segs : coilsegments,
				stepx : stepx, 
				stepy : stepy, 
				stepz : stepz,
				});
		}


		function RunVisualization()
		{
			var canvasElement = document.getElementById("canvas");
			
			
			
			var cameraX = parseFloat($('#camera_x').val());
			var cameraY = parseFloat($('#camera_y').val());
			var cameraZ = parseFloat($('#camera_z').val());
			var rotX = parseFloat($('#camera_rotx').get(0).value);
			var rotY = parseFloat($('#camera_roty').get(0).value);
			var rotZ = parseFloat($('#camera_rotz').get(0).value);
			var fieldType = parseFloat($('#fieldtype').get(0).value);
			var showNormaizedField = $('#normalized').prop('checked');

			//console.log($('input:radio[name=cameratype]:checked').val());
			var isCameraOrthoView = $('input:radio[name=cameratype]:checked').val() === 'Orthogonal' ? true : false;

			var sliderCutterZ = parseFloat($('#sliderfieldcutter').val());

			var scene = new THREE.Scene();
			//var camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			//var camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 0.1, 100 );
			var camera = null;

			if(isCameraOrthoView)
				camera = new THREE.OrthographicCamera( -5, 5, 5, -5, 0.1, 1000 );
			else
				camera = new THREE.PerspectiveCamera( 75, canvasElement.clientWidth / canvasElement.clientHeight, 0.1, 100 );

			camera.position.x = cameraX;
			camera.position.y = cameraY;
			camera.position.z = cameraZ;
			
			
			//ProtoMag.RotX = rotX == 0 ? 0 : pi/rotX;
			//ProtoMag.RotY = rotY == 0 ? 0 : pi/rotY;;
			//ProtoMag.RotZ = rotZ == 0 ? 0 : pi/rotZ;;
	   				
			rotX = rotX == 0 ? 0 : pi/rotX;
			rotY = rotY == 0 ? 0 : pi/rotY;;
			rotZ = rotZ == 0 ? 0 : pi/rotZ;;

			
			var renderer = null;
			if (window.WebGLRenderingContext)
			{
				renderer = new THREE.WebGLRenderer({canvas:canvasElement});
			}
			else
			{
				renderer = new THREE.CanvasRenderer({canvas:canvasElement});		
			}
			renderer.setSize( canvasElement.clientWidth, canvasElement.clientHeight );
			
			var mesh = ProtoMag.Mesh;
			var UVW = ProtoMag.VectorField;
			var coil = ProtoMag.CoildMesh;

			if(mesh === undefined || UVW === undefined)
			{
				ProtoMag.log('cannot run visualization, run simulation first');
				return;
			}

			//if(ProtoMag.root === undefined)
			var rootNode = new THREE.Object3D();
			
			//show field
			ProtoMag.showVectorField(rootNode,fieldType,showNormaizedField,mesh,UVW,sliderCutterZ);
				
			//show coil
			ProtoMag.showLineSegments(rootNode,coil);
				
			scene.add(rootNode);
			
			//ProtoMag.root = rootNode;
			
			rootNode.rotation.x = rotX;
			rootNode.rotation.y = rotY;
			rootNode.rotation.z = rotZ;
			
			
			//http://stackoverflow.com/questions/18347256/trackballcontrols-in-three-js
			//http://threejs.org/examples/misc_controls_trackball.html
			var controls = new THREE.TrackballControls(camera,renderer.domElement);
			controls.rotateSpeed = 1.0;
			controls.zoomSpeed = 1.2;
			controls.panSpeed = 0.8;
			controls.noZoom = false;
			controls.noPan = false;
			controls.staticMoving = true;
			controls.dynamicDampingFactor = 0.3;
			controls.keys = [ 65, 83, 68 ];
			//controls.addEventListener( 'change', Render );
			
			ProtoMag.controls = controls;
			
			
			//Render Scene
			//renderer.render(scene, camera);			
			ProtoMag.renderer = renderer;
			ProtoMag.camera = camera;
			ProtoMag.scene = scene;			
			Animate();
		}
		
		function Animate()
		{
		
		//http://carvisualizer.plus360degrees.com/threejs/js/RequestAnimationFrame.js
			Render();
			requestAnimationFrame(Animate);
		}
		
		function Render()
		{
			ProtoMag.renderer.render(ProtoMag.scene, ProtoMag.camera);
			ProtoMag.controls.update();
		}

		</script>


	<!-- MAGNETIC SIMULATOR OBJECT -->
    <script type="text/javascript" >

      function namespace(namespaceString) {
			var parts = namespaceString.split('.'),
				parent = window,
				currentPart = '';

			for(var i = 0, length = parts.length; i < length; i++) {
				currentPart = parts[i];
				parent[currentPart] = parent[currentPart] || {};
				parent = parent[currentPart];
			}
			return parent;
		}

		var ProtoMag = namespace("DeNaCoR.demo1");

      ProtoMag.Sim = function(args)
      {
			//draw grid
			//ProtoMag.drawGrid();

			//var progress = 1;			
			ProtoMag.progress(1);

			//define domain
			var ND = args.dim;
			//var Dom = 	[[-1.1, 1],
			//			[-1.1, 1],
			//			[0.1, 10]];
			
			var Dom = 	[[-args.stepx/2 * args.dim, args.stepx/2 * args.dim],
						[-args.stepy/2 * args.dim, args.stepy/2 * args.dim],
						[-args.stepz/2 * args.dim, args.stepz/2 * args.dim]];
			
			// Induction constant
			var gamma = 1;

			//% Integration step size
			var ds = 0.1;

			//%% Induction curve
			var coil = ProtoMag.circleGen(0,0,0,0.5, args.segs);
			var L;
			var Nl;
			var menu1selection = 4;
			switch(menu1selection) //menu('Choose a test case:', 'Straight wire', 'Bent wire', 'Solenoid');
			{
			case 1:
				//% Test case 1: Straight wire
				L = [[0, 0, 0],
					 [0, 0, 5]];
				Nl = 2;//sizof(L)/3
				break;
			case 2:
				//% Test case 2: Bent wire
				L = [[-.5, 0, 0],
					 [-.5, 0, 4],
					 [1.5, 0, 4]];
				Nl = 3;//sizeof(L)/3
				break;
			case 3:
				//% Test case 3: Solenoid
				var theta = numeric.linspace(0, 15*pi, 70);
				//L = [cos(theta') sin(theta') theta'/10];
				break;
			case 4:
				L = coil;
				Nl = args.segs;
				break;
			}

			//%% Declaration of variables
			//% Induction vector components B = (U, V, W);
			var UVW = ProtoMag.createArray(ND, ND, ND, [0,0,0]);

			//% Volume Mesh
			var mesh = ProtoMag.meshgrid(
								numeric.linspace(Dom[0][0], Dom[0][1], ND),
								numeric.linspace(Dom[1][0], Dom[1][1], ND),
								numeric.linspace(Dom[2][0], Dom[2][1], ND));
			var step = 1;
			var final_step = (ND*ND*ND);
			
			
			for(i = 0; i<ND; i++){
				for(j = 0;j<ND;j++){
					for(k = 0;k<ND;k++){

					//% Ptest is the point of the field where we calculate induction
					var pTest = mesh[i][j][k];//mesh[X(i,j,k),Y(i,j,k),Z(i,j,k)];

					//% The curve is discretized in Nl points, we iterate on the Nl-1
					//% segments. Each segment is discretized with a "ds" length step
					//% to evaluate a "dB" increment of the induction "B".
					for(pCurv = 0;pCurv<Nl-1;pCurv++)
					{
						//% Length of the curve element
						var diflen = numeric.sub(L[pCurv],L[pCurv+1]);
						var len = numeric.norm2(diflen);

						//% Number of points for the curve-element discretization
						var len_ds = numeric.div(len,ds);
						var Npi = Math.ceil(len/ds);
						if(Npi < 3){
							//ProtoMag.log("ERROR Integration step is too big!!");
						}

						//% Curve-element discretization
						var Lx = numeric.linspace(L[pCurv][0], L[pCurv+1][0], Npi);
						var Ly = numeric.linspace(L[pCurv][1], L[pCurv+1][1], Npi);
						var Lz = numeric.linspace(L[pCurv][2], L[pCurv+1][2], Npi);

						var Ldiscrete = new Array(Npi);
						for(ii = 0;ii< Npi; ii++)
						{
							Ldiscrete[ii] = [Lx[ii],Ly[ii],Lz[ii]];
						}

						//% Integration
						for(s = 0;s<Npi-1;s++)
						{
							//% Vector connecting the infinitesimal curve-element
							//% point and field point "pTest"
							var Rxyz = numeric.sub(Ldiscrete[s] , pTest);
							//var Rx = numeric.sub(Lx[s] , pTest[0]);
							//var Ry = numeric.sub(Ly[s] , pTest[1]);
							//var Rz = numeric.sub(Lz[s] , pTest[2]);

							//% Infinitesimal curve-element components
							var dLxyz = numeric.sub(Ldiscrete[s+1] , Ldiscrete[s]);
							//var dLx = numeric.sub(Lx[s+1] , Lx[s]);
							//var dLy = numeric.sub(Ly[s+1] , Ly[s]);
							//var dLz = numeric.sub(Lz[s+1] , Lz[s]);

							//% Modules
							//var dL = Math.sqrt(Math.pow(dLx,2) + Math.pow(dLy,2) + Math.pow(dLz,2));
							var dLn = numeric.norm2(dLxyz);
							//var R = Math.sqrt(Math.pow(Rx,2) + Math.pow(Ry,2) + Math.pow(Rz,2));
							var Rn = numeric.norm2(Rxyz);

							//% Biot-Savart
							var dUVW = numeric.mul( ProtoMag.crossprod(Rxyz,dLxyz), gamma/4/pi/Rn/Rn/Rn);
							//var dU = gamma/4/pi*(dLy*Rz - dLz*Ry)/R/R/R;
							//var dV = gamma/4/pi*(dLz*Rx - dLx*Rz)/R/R/R;
							//var dW = gamma/4/pi*(dLx*Ry - dLy*Rx)/R/R/R;

							//% Add increment to the main field
							UVW[i][j][k] = numeric.add(UVW[i][j][k], numeric.mul(dUVW, args.loops) );
							//U[i][j][k] += dU;
							//V[i][j][k] += dV;
							//W[i][j][k] += dW;
						}
					}

					ProtoMag.progress( Math.floor(  ( step / final_step ) * 100 ));
					step++;
				}}}

				ProtoMag.progress(100);


				ProtoMag.CoildMesh = coil;
				ProtoMag.Mesh = mesh;
				ProtoMag.VectorField = UVW;
		}

	   ProtoMag.showVectorField = function(node,fieldType,normalized,vecPos,vecDir,cutZ)
	   {
			var xgvL = vecPos.length;
			var ygvL = vecPos[0].length;
			var zgvL = vecPos[0][0].length;
			
			var vecNorm = ProtoMag.normalizeArray3(vecDir);
			
			var MinMax = ProtoMag.getMinMaxField(vecDir);			
			

			
			for(i = 0; i < xgvL; i++)
			{
				for(j = 0; j < ygvL; j++)
				{
					for(k = 0; k < zgvL; k++)
					{
						if(cutZ < 0 || k == cutZ)
						{
						
						
							var mesh = null;
															
							var mag = numeric.norm2(vecDir[i][j][k]);
							
							var color = ProtoMag.getColorMapValue(MinMax,mag);
							
							if(normalized)
								mag = 0.25;
							else
								mag = numeric.norm2(vecDir[i][j][k]);
								
							
							
							
							if(fieldType == 0)
							{
							   //( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded )
								var geometry = new THREE.CylinderGeometry(0,.05,0.4,4,2,false);
								var material = new THREE.MeshBasicMaterial( { color: color } );
								
								mesh = new THREE.Mesh( geometry, material );
								
								//mesh.doubleSided = true;
								
								mesh.position = new THREE.Vector3(vecPos[i][j][k][0],vecPos[i][j][k][1],vecPos[i][j][k][2]);
								//arrow.lookAt(new THREE.Vector3(vecNorm[i][j][k][0],vecNorm[i][j][k][1],vecNorm[i][j][k][2]));
								
								ProtoMag.setDir(mesh,new THREE.Vector3(vecNorm[i][j][k][0],vecNorm[i][j][k][1],vecNorm[i][j][k][2]));
								
							}
						
							if(fieldType == 1)
							{
								mesh = new THREE.ArrowHelper(
									new THREE.Vector3(vecNorm[i][j][k][0],vecNorm[i][j][k][1],vecNorm[i][j][k][2]), 
									new THREE.Vector3(vecPos[i][j][k][0],vecPos[i][j][k][1],vecPos[i][j][k][2]),
									mag + 0.01,
									color);
							}
						
							if(fieldType == 2)
							{	

								var rad = ( mag / MinMax.max ) * 0.1 + 0.01 ;// Math.min(mag * 10.5, 1.0);
								
								//radius segments ring
								var geometry = new THREE.SphereGeometry( rad , 8, 8);
								var material = new THREE.MeshBasicMaterial( { color: color } );
								
								//centre, radius
								var mesh = new THREE.Mesh( geometry, material);
								mesh.position = new THREE.Vector3(vecPos[i][j][k][0],vecPos[i][j][k][1],vecPos[i][j][k][2]);
							}
							
							node.add( mesh );
						}
					}
				}
			}
			
			
	   }
	   
		
		ProtoMag.getColorMapValue = function (MinMax, val)
		{
					
			if(ProtoMag.ColorMap === undefined)
			{
				ProtoMag.ColorMap = [
				//Blues
				0x0000FF,
				0x005CFF,
				0x00B9FF,
				0x00FFE7,
				//Greens
				0x00FF8B,
				0x00FF2E,
				0x2EFF00,
				0x8BFF00,
				//Yellow-Orange-Red
				0xE7FF00,
				0xFFB900,
				0xFF5C00,
				0xFF0000
				];
			}
		
			var range = MinMax.max - MinMax.min;
			
			if( range <= 0)
				ProtoMag.log("ERROR minmax mismatch");
			
			var step = range / ProtoMag.ColorMap.length;
			
			var index =  val / step;
			
			index = Math.min( Math.floor(index), ProtoMag.ColorMap.length - 1 );
			
			//DEBUG
			if(index < 0 || index > 11 )
				ProtoMag.log("WRONG ColorMap index: "+index);
			
			return ProtoMag.ColorMap[index];			
		}
		   
	   ProtoMag.setDir = function (mesh,dir)
	   {
		var axis = new THREE.Vector3();
		var radians;
		// dir is assumed to be normalized

			if ( dir.y > 0.99999 ) {

					mesh.quaternion.set( 0, 0, 0, 1 );

			} else if ( dir.y < - 0.99999 ) {

					mesh.quaternion.set( 1, 0, 0, 0 );

			} else {

					axis.set( dir.z, 0, - dir.x ).normalize();

					radians = Math.acos( dir.y );

					mesh.quaternion.setFromAxisAngle( axis, radians );
			}
	   }

	   ProtoMag.showLineSegments = function(node,pointwise)
	   {
			var geometry = new THREE.Geometry();
			var material = new THREE.LineBasicMaterial( { color: 0xEEEEEE, linewidth : 3 } );

			for(i = 0; i < pointwise.length; i++)
			{
				geometry.vertices.push(new THREE.Vector3(pointwise[i][0],pointwise[i][1],pointwise[i][2]));
			}

			var lines = new THREE.Line( geometry, material);
			lines.position.set(0,0,0);

			node.add(lines);
			
			//LineBasicMaterial( parameters )
			//parameters is an object with one or more properties defining the material's appearance.
			//color — Line color in hexadecimal. Default is 0xffffff.
			//linewidth — Line thickness. Default is 1.
			//linecap — Define appearance of line ends. Default is 'round'.
			//linejoin — Define appearance of line joints. Default is 'round'.
			//vertexColors — Define whether the material uses vertex colors, or not. Default is false.
			//fog — Define whether the material color is affected by global fog settings. Default is false.
			//%% Graphic
			//figure(1)
	   }

		ProtoMag.drawGrid = function()
		{
			var canvas = document.getElementById("canvas");
			var context = canvas.getContext("2d");
			//b_context.fillRect(50, 25, 150, 100);

			console.log('canvas.height:'+canvas.height);

			for (var x = 0.5; x < canvas.width; x += 10) {
			  context.moveTo(x, 0);
			  context.lineTo(x, canvas.height);
			}

			for (var y = 0.5; y < canvas.height; y += 10) {
			  context.moveTo(0, y);
			  context.lineTo(canvas.width, y);
			}
			context.strokeStyle = "#eee";
			context.stroke();

		}


	   ProtoMag.meshgrid = function(xgv,ygv,zgv)
	   {
			//[X,Y,Z] = meshgrid(xgv,ygv,zgv) produces three-dimensional coordinate arrays.
			//The output coordinate arrays X, Y, and Z contain copies of the grid vectors xgv, ygv, and zgv respectively.
			//The sizes of the output arrays are determined by the length of the grid vectors.
			//For grid vectors xgv, ygv, and zgv of length M, N, and P respectively, X, Y, and Z will have N rows, M columns, and P pages.

		   var xgvL = xgv.length;
		   var ygvL = ygv.length;
		   var zgvL = zgv.length;

		   var M = ProtoMag.createArray(xgvL, ygvL, zgvL, [0,0,0]);

		   for(i = 0; i < xgvL; i++)
		   {
			   for(j = 0; j < ygvL; j++)
			   {
					for(k = 0; k < zgvL; k++)
					{
						M[i][j][k] = [xgv[i],ygv[j],zgv[k]];
					}
			   }
		   }

			return M;
	   }

	   ProtoMag.createArray = function(a,b,c,val)
	   {
		   var A = new Array(a);

		   for(i = 0; i<a; i++)
		   {
			   A[i] = new Array(b);

			   for(j = 0; j < b; j++)
			   {
				   A[i][j] = new Array(c);

				   for(k = 0; k < c; k++)
				   {
					   A[i][j][k] = val;
				   }
			   }
		   }
		   return A;
	   }

	   ProtoMag.normalizeArray3 = function(array)
	   {
			var dim1 = array.length;
			var dim2 = array[0].length;
			var dim3 = array[0][0].length;

			var narray = ProtoMag.createArray(dim1,dim2,dim3,[0,0,0]);

		   for(i = 0; i < dim1; i++)
		   {
			   for(j = 0; j < dim2; j++)
			   {
					for(k = 0; k < dim3; k++)
					{
					 var n = numeric.norm2(array[i][j][k]);
					 narray[i][j][k] = numeric.div(array[i][j][k], n);
					}
				}
			}

			return narray;
	   }
		   
	   ProtoMag.getMinMaxField = function(array)
	   {
			var dim1 = array.length;
			var dim2 = array[0].length;
			var dim3 = array[0][0].length;

			var max = 0;
			var min = 9999999;

		   for(i = 0; i < dim1; i++)
		   {
			   for(j = 0; j < dim2; j++)
			   {
					for(k = 0; k < dim3; k++)
					{
					 var val = numeric.norm2(array[i][j][k]);
					 
					 if(val > max) max = val;
					 
					 if(val < min) min = val;
					 
					}
				}
			}

			return {max : max, min : min};
	   }

	   ProtoMag.log = function(text)
	   {
		   console.log(text);
	   }

	   ProtoMag.progress = function(percent)
	   {
		   //$("#progressbar").progressbar({ value: percent });
		   setProgress(percent);
	   }

	   ProtoMag.crossprod = function(u,v)
	   {
			return [u[1]*v[2]-u[2]*v[1],
					u[2]*v[0]-u[0]*v[2],
					u[0]*v[1]-u[1]*v[0]];
	   }

	   ProtoMag.circleGen = function(x,y,z,r,nsegments)
	   {
			//(x + r*cos(alpha), y + r*sin(alpha)
			var pi = Math.atan(1)*4;
			var anglePerSegment = 2*pi/nsegments;
			var circlexy = new Array(nsegments+1);

			for(i = 0; i < nsegments; i++)
			{
				//circlexy[i] = new THREE.Vector3(x + r * Math.cos(anglePerSegment*i), y + r * Math.sin(anglePerSegment*i), z);
				circlexy[i] = [x + r * Math.cos(anglePerSegment*i), y + r * Math.sin(anglePerSegment*i), z];
			}

			circlexy[nsegments] = circlexy[0];

			return circlexy;
	   }
		   
		   
        </script>

    </head>
    <body>

		<header>
			<div id="divHelloWorld">Welcome to ProtoMag</div>
			<div id="progressbar_container"><div id="progressbar"></div></div>		
        </header>
<table>
<tr>
<td width="400px">

		<div><div id="SL_button" class="ImTranslatorLogo" style="display: none;"></div><div id="SL_shadow_translation_result2" style="display: none;"></div><div id="SL_shadow_translator" style="display: none;"><div id="SL_planshet"><div id="SL_TB"><div class="ImTranslatorLogo"></div><table cellspacing="1" border="0" id="SL_tables"><tbody><tr><td class="SL_td" align="left" width="20%"><div id="SL_lng_from">English&nbsp;»</div></td><td class="SL_td" align="left" width="20%"><select id="SL_lng_to"><option value="af">Afrikaans</option><option value="sq">Albanian</option><option value="ar">Arabic</option><option value="hy">Armenian</option><option value="az">Azerbaijani</option><option value="eu">Basque</option><option value="bn">Bengali</option><option value="be">Belarusian</option><option value="bg">Bulgarian</option><option value="ca">Catalan</option><option value="zh-CN">Chinese&nbsp;(Simp)</option><option value="zh-TW">Chinese&nbsp;(Trad)</option><option value="hr">Croatian</option><option value="cs">Czech</option><option value="da">Danish</option><option value="nl">Dutch</option><option value="en">English</option><option value="eo">Esperanto</option><option value="et">Estonian</option><option value="tl">Filipino</option><option value="fi">Finnish</option><option value="fr">French</option><option value="gl">Galician</option><option value="ka">Georgian</option><option value="de">German</option><option value="el">Greek</option><option value="gu">Gujarati</option><option value="ht">Haitian&nbsp;Creole</option><option value="iw">Hebrew</option><option value="hi">Hindi</option><option value="hu">Hungarian</option><option value="is">Icelandic</option><option value="id">Indonesian</option><option value="ga">Irish</option><option value="it">Italian</option><option value="ja">Japanese</option><option value="kn">Kannada</option><option value="ko">Korean</option><option value="lo">Lao</option><option value="la">Latin</option><option value="lv">Latvian</option><option value="lt">Lithuanian</option><option value="mk">Macedonian</option><option value="ms">Malay</option><option value="mt">Maltese</option><option value="no">Norwegian</option><option value="fa">Persian</option><option value="pl">Polish</option><option value="pt">Portuguese</option><option value="ro">Romanian</option><option value="ru">Russian</option><option value="sr">Serbian</option><option value="sk">Slovak</option><option value="sl">Slovenian</option><option selected="" value="es">Spanish</option><option value="sw">Swahili</option><option value="sv">Swedish</option><option value="ta">Tamil</option><option value="te">Telugu</option><option value="th">Thai</option><option value="tr">Turkish</option><option value="uk">Ukrainian</option><option value="ur">Urdu</option><option value="vi">Vietnamese</option><option value="cy">Welsh</option><option value="yi">Yiddish</option></select></td><td class="SL_td" width="13%" align="center">&nbsp;</td><td class="SL_td" width="8%" align="center"><div id="SL_TTS_voice" title="Listen to the translation"></div></td><td class="SL_td" width="8%" align="center"><div class="SL_copy_hand" id="SL_copy" title="Select text"></div></td><td class="SL_td" width="8%" align="center"><div class="SL_font_off" id="SL_bbl_font" title="Font size"></div></td><td class="SL_td" width="8%" align="center"><a href="chrome-extension://noaijdpnepcgjemiklgfkcfbkokogabh/history.html" target="_blank"><div class="SL_TH" title="Translation history"></div></a></td><td class="SL_td" width="5%"></td><td class="SL_td" width="8%" align="right"><div class="SL_pin_off" id="SL_pin" title="Pin pup-up bubble"></div></td></tr></tbody></table></div></div><div id="SL_shadow_translation_result"></div><div id="SL_bbl_donate" title="Make a small contribution"></div><div id="SL_Balloon_options"><a href="chrome-extension://noaijdpnepcgjemiklgfkcfbkokogabh/feedback.html" class="SL_options" title="Feedback" target="_blank">Feedback</a>&nbsp;:&nbsp;<a href="chrome-extension://noaijdpnepcgjemiklgfkcfbkokogabh/history.html" class="SL_options" title="Translation history" target="_blank">History</a>&nbsp;:&nbsp;<a href="chrome-extension://noaijdpnepcgjemiklgfkcfbkokogabh/options-bbl.html" target="_blank" class="SL_options" title="Show options">Options</a></div></div></div>
		
		<form novalidate>
			<!--<input name="q" placeholder="Go to a Website">-->
			<ul id="maintoolbar">
				<li>
					<fieldset class="fields">
						<legend>Camera Type:</legend>
						<input id="cameratype0" type="radio" name="cameratype" value="Orthogonal" checked>Orthogonal
						</br>
						<input type="radio" name="cameratype" value="Prespective">Prespective
					</fieldset>
				</li>
				<li>
					<fieldset class="fields">
						<legend>Camera Control:</legend>
						<ul class="infield_h">
							<li>
								<ul class="infield_v">
									<li>
										<label for="camera_x">TX:</label>
										<input id="camera_x" type="number" min="-10" max="10" step="1" value="0" />
									</li>
									<li>

										<label for="camera_x">TY:</label>
										<input id="camera_y" type="number" min="-10" max="10" step="1" value="0" />
									</li>
									<li>
										<label for="camera_x">TZ:</label>
										<input id="camera_z" type="number" min="-40" max="40" step="1" value="15" />
									</li>
								</ul>
							</li>
							<li>
								<ul class="infield_v">
									<li>
										<label for="camera_rotx">RX:</label>
										<select id="camera_rotx">
										  <option value="0" selected>0</option>
										  <option value="1">PI</option>
										  <option value="2">PI/2</option>
										  <option value="4">PI/4</option>
										  <option value="8">PI/8</option>
										</select>
									</li>
									<li>
										<label for="camera_roty">RY:</label>
										<select id="camera_roty">
										  <option value="0" selected>0</option>
										  <option value="1">PI</option>
										  <option value="2">PI/2</option>
										  <option value="4">PI/4</option>
										  <option value="8">PI/8</option>
										</select>
									</li>
									<li>
										<label for="camera_rotz">RZ:</label>
										<select id="camera_rotz">
										  <option value="0" selected>0</option>
										  <option value="1">PI</option>
										  <option value="2">PI/2</option>
										  <option value="4">PI/4</option>
										  <option value="8">PI/8</option>
										</select>
									</li>
									<li class="set_camera_buttons">
									<input type="button" id="set_camerax" value="x">
									<input type="button" id="set_cameray" value="y">
									<input type="button" id="set_cameraz" value="z">
									</li>
								</ul>
							</li>
						</ul>
					</fieldset>
				</li>
				<li>
					<fieldset class="fields">
						<legend>Domain:</legend>
						<ul>
							<li>
								<label for="coilloops">Wire Loops :</label>
								<input id="coilloops" type="number" min="1" max="1000" step="10" value="1" />
							</li>
							<li>
								<label for="coilsegs">Wire Segments :</label>
								<input id="coilsegs" type="number" min="1" max="100" step="1" value="16" />
							</li>
							<li>
								<label for="domaindim">Grid NxNxN :</label>
								<input id="domaindim" type="number" min="1" max="20" step="1" value="7" />
							</li>
							<li>
								<label for="domain_step_x">Grid Step X :</label>
								<input id="domain_step_x" type="number" min="0.1" max="10" step="0.25" value="0.25" />
							</li>
							<li>
								<label for="domain_step_y">Grid Step Y :</label>
								<input id="domain_step_y" type="number" min="0.1" max="10" step="0.25" value="0.25" />
							</li>
							<li>
								<label for="domain_step_z">Grid Step Z :</label>
								<input id="domain_step_z" type="number" min="0.1" max="10" step="0.5" value="5" />
							</li>
							
						</ul>
					</fieldset>
				</li>
				<li>
					<fieldset class="fields">
						<legend>Mag Field:</legend>
							<label for="fieldtype">Type:</label>
							<select id="fieldtype">
							  <option value="0" selected>Cones</option>
							  <option value="1">Arrows</option>
							  <option value="2">Spheres</option>
							</select>
							</br>
							<label for="sliderfieldcutter">Cut on Z:</label>
							<input id="sliderfieldcutter" type="range" min="-1" max="7" step="1" value="-1" />
							</br>
							<input id="normalized" type="checkbox"  value="true">Normalized L</input>
					</fieldset>
				</li>
				<li>
					<input id="gosim" type="button" value="GO Sim" />
					<input id="govis" type="button" value="GO Vis" />
				</li>
			</ul>
		</form>
</td>
<td>
       <canvas id="canvas" width="800" height="600"></canvas>
</td>
</tr>
</table>

		<footer>
		Copyright 2013 Petar Petrov (www.ppetrov.net)
		</footer>
    </body>
</html>
